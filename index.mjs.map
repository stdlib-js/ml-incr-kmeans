{"version":3,"file":"index.mjs","sources":["../lib/matrix.js","../lib/copy_matrix.js","../lib/vector.js","../lib/copy_vector.js","../lib/validate.js","../lib/normalize.js","../lib/normalize_matrix.js","../lib/standardize.js","../lib/standardize_matrix.js","../lib/squared_euclidean.js","../lib/euclidean.js","../lib/dot.js","../lib/squared_cosine.js","../lib/squared_correlation.js","../lib/init_kmeansplusplus.js","../lib/find_closest_centroid.js","../lib/update_centroid.js","../lib/init.js","../lib/init_forgy.js","../lib/init_sample.js","../lib/init_clusters.js","../lib/stats.js","../lib/incrstats.js","../lib/main.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport Float64Array from '@stdlib/array-float64';\nimport ctor from '@stdlib/ndarray-ctor';\nimport bctor from '@stdlib/ndarray-base-ctor';\n\n\n// MAIN //\n\n/**\n* Returns a matrix.\n*\n* @private\n* @param {PositiveInteger} m - number of rows\n* @param {PositiveInteger} n - number of columns\n* @param {boolean} bool - boolean indicating whether to create a low-level ndarray\n* @returns {ndarray} matrix\n*/\nfunction createMatrix( m, n, bool ) {\n\tvar strides;\n\tvar buffer;\n\tvar shape;\n\tvar f;\n\n\tif ( bool ) {\n\t\tf = bctor;\n\t} else {\n\t\tf = ctor;\n\t}\n\tbuffer = new Float64Array( m*n );\n\tshape = [ m, n ];\n\tstrides = [ n, 1 ];\n\treturn f( 'float64', buffer, shape, strides, 0, 'row-major' );\n}\n\n\n// EXPORTS //\n\nexport default createMatrix;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport { ndarray as gcopy } from '@stdlib/blas-base-gcopy';\n\n\n// MAIN //\n\n/**\n* Copies matrix elements to another matrix.\n*\n* ## Notes\n*\n* -   Why not just use `gcopy` directly? Because `gcopy` 1) assumes only a single stride per strided array and 2) as we cannot assume that a source matrix is single-segment contiguous, we fall back to copying source matrix \"chunks\" (rows) to a destination matrix. Assuming the source matrix is row-major, then the implementation should be reasonably performant.\n*\n* @private\n* @param {ndarray} Y - destination matrix\n* @param {ndarray} X - source matrix\n* @returns {ndarray} destination matrix\n*/\nfunction copyMatrix( Y, X ) { // TODO: once an ndarray engine is written, determine whether this function can be replaced by a standalone package\n\tvar xbuf;\n\tvar ybuf;\n\tvar sx1;\n\tvar sx2;\n\tvar sy1;\n\tvar sy2;\n\tvar ox;\n\tvar oy;\n\tvar M;\n\tvar N;\n\tvar i;\n\n\tM = X.shape[ 0 ];\n\tN = X.shape[ 1 ];\n\n\txbuf = X.data;\n\tybuf = Y.data;\n\n\tsx1 = X.strides[ 0 ];\n\tsx2 = X.strides[ 1 ];\n\n\tsy1 = Y.strides[ 0 ];\n\tsy2 = Y.strides[ 1 ];\n\n\tox = X.offset;\n\toy = Y.offset;\n\n\tfor ( i = 0; i < M; i++ ) {\n\t\tgcopy( N, xbuf, sx2, ox, ybuf, sy2, oy );\n\t\tox += sx1;\n\t\toy += sy1;\n\t}\n\treturn Y;\n}\n\n\n// EXPORTS //\n\nexport default copyMatrix;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport Float64Array from '@stdlib/array-float64';\nimport ctor from '@stdlib/ndarray-ctor';\nimport bctor from '@stdlib/ndarray-base-ctor';\n\n\n// MAIN //\n\n/**\n* Returns a vector.\n*\n* @private\n* @param {PositiveInteger} N - number of elements\n* @param {boolean} bool - boolean indicating whether to create a low-level ndarray\n* @returns {ndarray} vector\n*/\nfunction createVector( N, bool ) {\n\tvar strides;\n\tvar buffer;\n\tvar shape;\n\tvar f;\n\n\tif ( bool ) {\n\t\tf = bctor;\n\t} else {\n\t\tf = ctor;\n\t}\n\tbuffer = new Float64Array( N );\n\tshape = [ N ];\n\tstrides = [ 1 ];\n\treturn f( 'float64', buffer, shape, strides, 0, 'row-major' );\n}\n\n\n// EXPORTS //\n\nexport default createVector;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport { ndarray as gcopy } from '@stdlib/blas-base-gcopy';\n\n\n// MAIN //\n\n/**\n* Copies vector elements to another vector.\n*\n* @private\n* @param {ndarray} out - destination vector\n* @param {ndarray} src - source vector\n* @returns {ndarray} destination vector\n*/\nfunction copyVector( out, src ) {\n\tgcopy( src.shape[0], src.data, src.strides[0], src.offset, out.data, out.strides[0], out.offset ); // eslint-disable-line max-len\n\treturn out;\n}\n\n\n// EXPORTS //\n\nexport default copyVector;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isObject from '@stdlib/assert-is-plain-object';\nimport hasOwnProp from '@stdlib/assert-has-own-property';\nimport { isPrimitive as isBoolean } from '@stdlib/assert-is-boolean';\nimport isArrayLike from '@stdlib/assert-is-array-like-object';\nimport { isPrimitive as isPositiveInteger } from '@stdlib/assert-is-positive-integer';\nimport contains from '@stdlib/assert-contains';\nimport format from '@stdlib/string-format';\nimport METRICS from './metrics.json';\nimport INIT_METHODS from './init_methods.json';\n\n\n// MAIN //\n\n/**\n* Validates function options.\n*\n* @private\n* @param {Object} opts - destination object\n* @param {Options} options - function options\n* @param {string} [options.metric] - distance metric\n* @param {ArrayLikeObject} [options.init] - method for determining initial centroids\n* @param {boolean} [options.normalize] - boolean indicating whether to normalize incoming data\n* @param {boolean} [options.copy] - boolean indicating whether to copy incoming data to prevent mutation during normalization\n* @param {*} [options.seed] - PRNG seed\n* @returns {(Error|null)} null or an error object\n*\n* @example\n* var opts = {};\n* var options = {\n*     'metric': 'euclidean',\n*     'init': [ 'kmeans++', 1, 1 ]\n* };\n* var err = validate( opts, options );\n* if ( err ) {\n*     throw err;\n* }\n*/\nfunction validate( opts, options ) {\n\tif ( !isObject( options ) ) {\n\t\treturn new TypeError( format( 'invalid argument. Options argument must be an object. Value: `%s`.', options ) );\n\t}\n\tif ( hasOwnProp( options, 'metric' ) ) {\n\t\topts.metric = options.metric;\n\t\tif ( !contains( METRICS, opts.metric ) ) {\n\t\t\treturn new TypeError( format( 'invalid option. `%s` option must be one of the following: \"%s\". Option: `%s`.', 'metric', METRICS.join( '\", \"' ), opts.metric ) );\n\t\t}\n\t}\n\tif ( hasOwnProp( options, 'init' ) ) {\n\t\tif ( !isArrayLike( options.init ) ) {\n\t\t\treturn new TypeError( format( 'invalid option. `%s` option must be an array-like object. Option: `%s`.', 'init', options.init ) );\n\t\t}\n\t\tif ( !contains( INIT_METHODS, options.init[ 0 ] ) ) {\n\t\t\treturn new TypeError( format( 'invalid option. `%s` option method must be one of the following: \"%s\". Option: `%s`.', 'init', INIT_METHODS.join( '\", \"' ), options.init[ 0 ] ) );\n\t\t}\n\t\topts.init[ 0 ] = options.init[ 0 ];\n\t\tif ( options.init.length > 1 ) {\n\t\t\topts.init[ 1 ] = options.init[ 1 ];\n\t\t\tif ( !isPositiveInteger( opts.init[ 1 ] ) ) {\n\t\t\t\treturn new TypeError( format( 'invalid option. First `%s` parameter option must be a positive integer. Option: `%s`.', 'init', opts.init[ 1 ] ) );\n\t\t\t}\n\t\t}\n\t\tif ( options.init.length > 2 ) {\n\t\t\topts.init[ 2 ] = options.init[ 2 ];\n\t\t\tif ( !isPositiveInteger( opts.init[ 2 ] ) ) {\n\t\t\t\treturn new TypeError( format( 'invalid option. Second `%s` parameter option must be a positive integer. Option: `%s`.', 'init', opts.init[ 2 ] ) );\n\t\t\t}\n\t\t}\n\t}\n\tif ( hasOwnProp( options, 'normalize' ) ) {\n\t\topts.normalize = options.normalize;\n\t\tif ( !isBoolean( opts.normalize ) ) {\n\t\t\treturn new TypeError( format( 'invalid option. `%s` option must be a boolean. Option: `%s`.', 'normalize', opts.normalize ) );\n\t\t}\n\t}\n\tif ( hasOwnProp( options, 'copy' ) ) {\n\t\topts.copy = options.copy;\n\t\tif ( !isBoolean( opts.copy ) ) {\n\t\t\treturn new TypeError( format( 'invalid option. `%s` option must be a boolean. Option: `%s`.', 'copy', opts.copy ) );\n\t\t}\n\t}\n\tif ( hasOwnProp( options, 'seed' ) ) {\n\t\topts.seed = options.seed;\n\t}\n\treturn null;\n}\n\n\n// EXPORTS //\n\nexport default validate;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport sqrt from '@stdlib/math-base-special-sqrt';\n\n\n// MAIN //\n\n/**\n* Normalizes a vector.\n*\n* @private\n* @param {NonNegativeInteger} N - number of elements\n* @param {NumericArray} X - strided array\n* @param {integer} strideX - stride\n* @param {NonNegativeInteger} offsetX - index offset\n* @returns {NumericArray} input array\n*/\nfunction normalize( N, X, strideX, offsetX ) { // TODO: eventually remove this function once project has implemented comparable functionality as a standalone package (e.g., BLAS, which may avoid the naive approach susceptible to overflow/overflow due to summing squares and computing the square root)\n\tvar xi;\n\tvar m;\n\tvar v;\n\tvar i;\n\n\tm = 0.0;\n\n\t// Compute the vector magnitude...\n\txi = offsetX;\n\tfor ( i = 0; i < N; i++ ) {\n\t\tv = X[ xi ];\n\t\tm += v * v;\n\t\txi += strideX;\n\t}\n\tm = sqrt( m );\n\n\t// Normalize the vector...\n\txi = offsetX;\n\tfor ( i = 0; i < N; i++ ) {\n\t\tX[ xi ] /= m;\n\t}\n\treturn X;\n}\n\n\n// EXPORTS //\n\nexport default normalize;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport norm from './normalize.js';\n\n\n// MAIN //\n\n/**\n* Normalizes matrix elements by row magnitudes.\n*\n* @private\n* @param {ndarray} mat - matrix to normalize\n* @returns {ndarray} input matrix\n*/\nfunction normalize( mat ) { // TODO: eventually remove this function once project has implemented comparable functionality as a standalone package\n\tvar mbuf;\n\tvar sm1;\n\tvar sm2;\n\tvar om;\n\tvar M;\n\tvar N;\n\tvar i;\n\n\tmbuf = mat.data;\n\tM = mat.shape[ 0 ];\n\tN = mat.shape[ 1 ];\n\tsm1 = mat.strides[ 0 ];\n\tsm2 = mat.strides[ 1 ];\n\tom = mat.offset;\n\n\tfor ( i = 0; i < M; i++ ) {\n\t\t// Normalize a matrix row:\n\t\tnorm( N, mbuf, sm2, om );\n\n\t\t// Update the index offset to point to the next row:\n\t\tom += sm1;\n\t}\n\treturn mat;\n}\n\n\n// EXPORTS //\n\nexport default normalize;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Normalizes a vector by standardization.\n*\n* @private\n* @param {NonNegativeInteger} N - number of elements\n* @param {NumericArray} X - strided array\n* @param {integer} strideX - stride\n* @param {NonNegativeInteger} offsetX - index offset\n* @param {NumericArray} mean - strided array containing the sample mean along each dimension\n* @param {integer} strideM - stride\n* @param {NonNegativeInteger} offsetM - index offset\n* @param {NumericArray} stdev - strided array containing the standard deviation along each dimension\n* @param {integer} strideS - stride\n* @param {NonNegativeInteger} offsetS - index offset\n* @returns {ndarray} input array\n*/\nfunction standardize( N, X, strideX, offsetX, mean, strideM, offsetM, stdev, strideS, offsetS ) { // eslint-disable-line max-len\n\tvar xi;\n\tvar mi;\n\tvar si;\n\tvar i;\n\n\t// TODO: consider moving to an \"extended\" BLAS package\n\n\txi = offsetX;\n\tmi = offsetM;\n\tsi = offsetS;\n\tfor ( i = 0; i < N; i++ ) {\n\t\tX[ xi ] = ( X[ xi ] - mean[ mi ] ) / stdev[ si ];\n\t\txi += strideX;\n\t\tmi += strideM;\n\t\tsi += strideS;\n\t}\n\treturn X;\n}\n\n\n// EXPORTS //\n\nexport default standardize;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport norm from './standardize.js';\n\n\n// MAIN //\n\n/**\n* Normalizes matrix elements by standardization.\n*\n* @private\n* @param {ndarray} mat - matrix to normalize\n* @param {Float64Array} stats - strided array containing the mean and standard deviation along each dimension\n* @returns {ndarray} input matrix\n*/\nfunction standardize( mat, stats ) { // TODO: eventually remove this function once project has implemented comparable functionality as a standalone package\n\tvar mbuf;\n\tvar sm1;\n\tvar sm2;\n\tvar om;\n\tvar M;\n\tvar N;\n\tvar i;\n\n\tmbuf = mat.data;\n\tM = mat.shape[ 0 ];\n\tN = mat.shape[ 1 ];\n\tsm1 = mat.strides[ 0 ];\n\tsm2 = mat.strides[ 1 ];\n\tom = mat.offset;\n\n\tfor ( i = 0; i < M; i++ ) {\n\t\t// Normalize a matrix row:\n\t\tnorm( N, mbuf, sm2, om, stats, 2, 0, stats, 2, 1 ); // Magic numbers come from knowing that the `stats` array is interleaved\n\n\t\t// Update the index offset to point to the next row:\n\t\tom += sm1;\n\t}\n\treturn mat;\n}\n\n\n// EXPORTS //\n\nexport default standardize;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport euclidean from './euclidean.js';\n\n\n// MAIN //\n\n/**\n* Computes the squared Euclidean distance between two data points.\n*\n* @private\n* @param {NonNegativeInteger} N - number of elements\n* @param {NumericArray} X - strided array\n* @param {PositiveInteger} strideX - stride\n* @param {NonNegativeInteger} offsetX - index offset\n* @param {NumericArray} Y - strided array\n* @param {PositiveInteger} strideY - stride\n* @param {NonNegativeInteger} offsetY - index offset\n* @returns {number} squared Euclidean distance\n*/\nfunction squaredEuclidean( N, X, strideX, offsetX, Y, strideY, offsetY ) { // TODO: consider moving to an \"extended\" BLAS package\n\tvar d = euclidean( N, X, strideX, offsetX, Y, strideY, offsetY );\n\treturn d * d;\n}\n\n\n// EXPORTS //\n\nexport default squaredEuclidean;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport sqrt from '@stdlib/math-base-special-sqrt';\n\n\n// MAIN //\n\n/**\n* Computes the Euclidean distance between two vectors.\n*\n* @private\n* @param {NonNegativeInteger} N - number of elements\n* @param {NumericArray} X - strided array\n* @param {PositiveInteger} strideX - stride\n* @param {NonNegativeInteger} offsetX - index offset\n* @param {NumericArray} Y - strided array\n* @param {PositiveInteger} strideY - stride\n* @param {NonNegativeInteger} offsetY - index offset\n* @returns {number} Euclidean distance\n*/\nfunction euclidean( N, X, strideX, offsetX, Y, strideY, offsetY ) { // TODO: remove and use BLAS implementation\n\tvar xi;\n\tvar yi;\n\tvar d;\n\tvar s;\n\tvar i;\n\n\txi = offsetX;\n\tyi = offsetY;\n\ts = 0.0;\n\tfor ( i = 0; i < N; i++ ) {\n\t\td = X[ xi ] - Y[ yi ];\n\t\ts += d * d;\n\t\txi += strideX;\n\t\tyi += strideY;\n\t}\n\treturn sqrt( s );\n}\n\n\n// EXPORTS //\n\nexport default euclidean;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Computes the dot product of two vectors.\n*\n* @private\n* @param {NonNegativeInteger} N - number of elements\n* @param {NumericArray} X - strided array\n* @param {PositiveInteger} strideX - stride\n* @param {NonNegativeInteger} offsetX - index offset\n* @param {NumericArray} Y - strided array\n* @param {PositiveInteger} strideY - stride\n* @param {NonNegativeInteger} offsetY - index offset\n* @returns {number} dot product\n*/\nfunction dot( N, X, strideX, offsetX, Y, strideY, offsetY ) { // TODO: remove and use BLAS implementation\n\tvar xi;\n\tvar yi;\n\tvar s;\n\tvar i;\n\n\txi = offsetX;\n\tyi = offsetY;\n\ts = 0.0;\n\tfor ( i = 0; i < N; i++ ) {\n\t\ts += X[ xi ] * Y[ yi ];\n\t\txi += strideX;\n\t\tyi += strideY;\n\t}\n\treturn s;\n}\n\n\n// EXPORTS //\n\nexport default dot;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport dot from './dot.js';\n\n\n// MAIN //\n\n/**\n* Computes the squared cosine distance between two data points.\n*\n* @private\n* @param {NonNegativeInteger} N - number of elements\n* @param {NumericArray} X - strided array\n* @param {PositiveInteger} strideX - stride\n* @param {NonNegativeInteger} offsetX - index offset\n* @param {NumericArray} Y - strided array\n* @param {PositiveInteger} strideY - stride\n* @param {NonNegativeInteger} offsetY - index offset\n* @returns {number} squared cosine distance\n*/\nfunction squaredCosine( N, X, strideX, offsetX, Y, strideY, offsetY ) { // TODO: consider moving to an \"extended\" BLAS package\n\tvar d = 1.0 - dot( N, X, strideX, offsetX, Y, strideY, offsetY );\n\treturn d * d;\n}\n\n\n// EXPORTS //\n\nexport default squaredCosine;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport dot from './dot.js';\n\n\n// MAIN //\n\n/**\n* Computes the squared correlation distance between two data points.\n*\n* @private\n* @param {NonNegativeInteger} N - number of elements\n* @param {NumericArray} X - strided array\n* @param {PositiveInteger} strideX - stride\n* @param {NonNegativeInteger} offsetX - index offset\n* @param {NumericArray} Y - strided array\n* @param {PositiveInteger} strideY - stride\n* @param {NonNegativeInteger} offsetY - index offset\n* @returns {number} squared correlation distance\n*/\nfunction squaredCorrelation( N, X, strideX, offsetX, Y, strideY, offsetY ) { // TODO: consider moving to an \"extended\" BLAS package\n\tvar d = 1.0 - dot( N, X, strideX, offsetX, Y, strideY, offsetY );\n\treturn d * d;\n}\n\n\n// EXPORTS //\n\nexport default squaredCorrelation;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport { factory as randint } from '@stdlib/random-base-discrete-uniform';\nimport { factory as randu } from '@stdlib/random-base-mt19937';\nimport PINF from '@stdlib/constants-float64-pinf';\nimport { ndarray as dcopy } from '@stdlib/blas-base-dcopy';\nimport squaredEuclidean from './squared_euclidean.js';\nimport squaredCosine from './squared_cosine.js';\nimport squaredCorrelation from './squared_correlation.js';\n\n\n// FUNCTIONS //\n\n/**\n* Applies a function for calculating the squared distance between each data point and a specified centroid.\n*\n* @private\n* @param {Array} out - output array\n* @param {Function} dist - distance function to apply\n* @param {PositiveInteger} npts - number of data points\n* @param {PositiveInteger} ndims - number of dimensions\n* @param {ndarray} matrix - data point matrix\n* @param {NonNegativeInteger} ci - centroid row index\n* @returns {Array} output array\n*/\nfunction dapply( out, dist, npts, ndims, matrix, ci ) {\n\tvar offsetC;\n\tvar offsetD;\n\tvar strideD;\n\tvar buf;\n\tvar i;\n\n\tbuf = matrix.data;\n\n\tstrideD = matrix.strides[ 0 ];\n\toffsetC = strideD * ci;\n\toffsetD = 0;\n\n\tfor ( i = 0; i < npts; i++ ) {\n\t\tout[ i ] = dist( ndims, buf, 1, offsetD, buf, 1, offsetC ); // Magic number `1` for stride is based on knowing that the matrix is row-major single-segment contiguous\n\t\toffsetD += strideD;\n\t}\n\treturn out;\n}\n\n\n// MAIN //\n\n/**\n* Initializes centroids by performing the k-means++ initialization procedure.\n*\n* ## Method\n*\n* The k-means++ algorithm for choosing initial centroids is as follows:\n*\n* 1.  Select a data point uniformly at random from a data set \\\\( X \\\\). This data point is first centroid and denoted \\\\( c_0 \\\\).\n*\n* 2.  Compute the distance from each data point to \\\\( c_0 \\\\). Denote the distance between \\\\( c_j \\\\) and data point \\\\( m \\\\) as \\\\( d(x_m, c_j) \\\\).\n*\n* 3.  Select the next centroid, \\\\( c_1 \\\\), at random from \\\\( X \\\\) with probability\n*\n*     ```tex\n*     \\frac{d^2(x_m, c_0)}{\\sum_{j=0}^{n-1} d^2(x_j, c_0)}\n*     ```\n*\n*     where \\\\( n \\\\) is the number of data points.\n*\n* 4.  To choose centroid \\\\( j \\\\),\n*\n*     a.   Compute the distances from each data point to each centroid and assign each data point to its closest centroid.\n*\n*     b.   For \\\\( i = 0,\\ldots,n-1 \\\\) and \\\\( p = 0,\\ldots,j-2 \\\\), select centroid \\\\( j \\\\) at random from \\\\( X \\\\) with probability\n*\n*          ```tex\n*          \\frac{d^2(x_i, c_p)}{\\sum_{\\{h; x_h \\exits C_p\\}} d^2(x_h, c_p)}\n*          ```\n*\n*          where \\\\( C_p \\\\) is the set of all data points closest to centroid \\\\( c_p \\\\) and \\\\( x_i \\\\) belongs to \\\\( c_p \\\\).\n*\n*          Stated more plainly, select each subsequent centroid with a probability proportional to the distance from the centroid to the closest centroid already chosen.\n*\n* 5.  Repeat step `4` until \\\\( k \\\\) centroids have been chosen.\n*\n* ## References\n*\n* -   Arthur, David, and Sergei Vassilvitskii. 2007. \"K-means++: The Advantages of Careful Seeding.\" In _Proceedings of the Eighteenth Annual Acm-Siam Symposium on Discrete Algorithms_, 1027–35. SODA '07. Philadelphia, PA, USA: Society for Industrial and Applied Mathematics. <http://dl.acm.org/citation.cfm?id=1283383.1283494>.\n*\n* @private\n* @param {ndarray} out - output centroids `kxd` matrix\n* @param {ndarray} buffer - data buffer\n* @param {string} metric - distance metric\n* @param {PositiveInteger} trials - number of potential centroids per iteration\n* @param {*} seed - PRNG seed\n* @returns {ndarray} centroids\n*/\nfunction kmeansplusplus( out, buffer, metric, trials, seed ) {\n\tvar centroids; // array of indices\n\tvar offsetC;\n\tvar randi;\n\tvar ndims;\n\tvar dhash;\n\tvar probs;\n\tvar rand;\n\tvar npts;\n\tvar csum;\n\tvar bsum;\n\tvar dist;\n\tvar obuf;\n\tvar buf;\n\tvar ind;\n\tvar sb1;\n\tvar sb2;\n\tvar so1;\n\tvar so2;\n\tvar oo;\n\tvar d2;\n\tvar bc;\n\tvar d;\n\tvar c;\n\tvar k;\n\tvar r;\n\tvar i;\n\tvar j;\n\tvar t;\n\n\tk = out.shape[ 0 ];\n\tndims = out.shape[ 1 ];\n\tnpts = buffer.shape[ 0 ];\n\n\tobuf = out.data;\n\tso1 = out.strides[ 0 ];\n\tso2 = out.strides[ 1 ];\n\too = out.offset;\n\n\tbuf = buffer.data;\n\tsb1 = buffer.strides[ 0 ];\n\tsb2 = buffer.strides[ 1 ];\n\n\t// Create seeded PRNGs:\n\trand = randu({\n\t\t'seed': seed\n\t});\n\trandi = randint({\n\t\t'seed': rand()\n\t});\n\trand = rand.normalized;\n\n\t// Determine the distance functions...\n\tif ( metric === 'cosine' ) {\n\t\tdist = squaredCosine;\n\t} else if ( metric === 'correlation' ) {\n\t\tdist = squaredCorrelation;\n\t} else {\n\t\tdist = squaredEuclidean;\n\t}\n\t// 1. Select a data point at random for the first centroid...\n\tc = randi( 0, npts-1 );\n\tif ( k === 1 ) {\n\t\t// For the trivial case of one centroid, we are done which means we can skip to setting the output centroid data...\n\t\treturn dcopy( ndims, buf, sb2, sb1*c, obuf, so2, oo );\n\t}\n\tcentroids = [ c ];\n\n\t// Create a scratch array for storing squared distances:\n\td2 = new Array( ndims );\n\n\t// Create a strided array for storing closest centroid results:\n\tdhash = new Array( npts*2 );\n\tind = 0;\n\tfor ( i = 0; i < npts; i++ ) {\n\t\tdhash[ ind ] = PINF; // squared distance\n\t\tdhash[ ind+1 ] = 0; // index of the closest centroid\n\t\tind += 2; // +stride\n\t}\n\t// Create a scratch array for storing cumulative probabilities:\n\tprobs = new Array( npts );\n\n\t// 2-5. For each data point, compute the distances to each centroid, find the closest centroid, and, based on the distance to the closest centroid, assign a probability to the data point to be chosen as centroid `c_j`...\n\tfor ( j = 1; j < k; j++ ) {\n\t\t// Note: instead of repeatedly computing centroid distances for each data point, we only need to compute the distances for the most recent centroid and to maintain a hash of closest distance results...\n\t\tdapply( d2, dist, npts, ndims, buffer, centroids[ j-1 ] );\n\t\tcsum = 0.0; // total cumulative distance\n\t\tind = 0;\n\t\tfor ( i = 0; i < npts; i++ ) {\n\t\t\tif ( d2[ i ] < dhash[ ind ] ) {\n\t\t\t\tdhash[ ind ] = d2[ i ];\n\t\t\t\tdhash[ ind+1 ] = j - 1;\n\t\t\t\tcsum += d2[ i ];\n\t\t\t} else {\n\t\t\t\tcsum += dhash[ ind ];\n\t\t\t}\n\t\t\tind += 2; // +stride\n\t\t}\n\t\t// Compute the cumulative probabilities...\n\t\tprobs[ 0 ] = dhash[ 0 ] / csum;\n\t\tind = 2;\n\t\tfor ( i = 1; i < npts; i++ ) {\n\t\t\tprobs[ i ] = probs[ i-1 ] + ( dhash[ ind ] / csum );\n\t\t\tind += 2; // +stride\n\t\t}\n\t\t// Based Arthur's and Vassilvitskii's paper \"kmeans++: The Advantages of Careful Seeding\" (see conclusion), randomly select candidate centroids and pick the candidate which minimizes the total squared distance...\n\t\tbsum = PINF; // best sum\n\t\tbc = -1; // best candidate\n\t\tfor ( t = 0; t < trials; t++ ) {\n\t\t\t// Use rejection sampling to handle edge case where the total cumulative probability does not equal unity due to accumulated floating-point errors and is less than `r` (*very* rarely should this require more than one iteration)...\n\t\t\tc = -1;\n\n\t\t\t// Note: the following should never choose an already chosen centroid (why? because a centroid's minimum squared distance is `0`, which means it will either correspond to a cumulative probability of `0` or will correspond to a cumulative probability equal to the previous cumulative probability, thus leading to the equivalent of a no-op iteration)\n\t\t\twhile ( c === -1 ) {\n\t\t\t\tr = rand(); // Note: `r` exists on the interval `[0,1)`\n\t\t\t\tfor ( i = 0; i < npts; i++ ) {\n\t\t\t\t\tif ( r < probs[ i ] ) {\n\t\t\t\t\t\tc = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Compute the sum of squared distances were we to include the candidate centroid...\n\t\t\tcsum = 0.0;\n\t\t\toffsetC = sb1 * c;\n\t\t\tind = 0;\n\t\t\tfor ( i = 0; i < npts; i++ ) {\n\t\t\t\td = dist( ndims, buf, 1, sb1*i, buf, 1, offsetC ); // Magic number `1` for stride as matrix is row-major single-segment contiguous\n\t\t\t\tif ( d < dhash[ ind ] ) {\n\t\t\t\t\tcsum += d;\n\t\t\t\t} else {\n\t\t\t\t\tcsum += dhash[ ind ];\n\t\t\t\t}\n\t\t\t\tind += 2; // +stride\n\t\t\t}\n\t\t\t// Determine if the candidate is the best candidate we have seen thus far...\n\t\t\tif ( csum < bsum ) {\n\t\t\t\tbsum = csum;\n\t\t\t\tbc = c;\n\t\t\t}\n\t\t}\n\t\t// Push the \"best\" candidate to our list of centroids:\n\t\tcentroids.push( bc );\n\t}\n\t// 6. Set centroid data...\n\tfor ( i = 0; i < k; i++ ) {\n\t\t// Note: the following is likely to be an \"out-of-order\" copy...\n\t\tdcopy( ndims, buf, sb2, sb1*centroids[i], obuf, so2, oo );\n\t\too += so1;\n\t}\n\treturn out;\n}\n\n\n// EXPORTS //\n\nexport default kmeansplusplus;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport PINF from '@stdlib/constants-float64-pinf';\n\n\n// MAIN //\n\n/**\n* Finds the closest centroid.\n*\n* @private\n* @param {Function} dist - distance function\n* @param {PositiveInteger} k - number of clusters\n* @param {PositiveInteger} ndims - number of dimensions\n* @param {NumericArray} C - strided array containing centroids\n* @param {PositiveInteger} strideC - centroid row stride\n* @param {NonNegativeInteger} offsetC - centroid index offset\n* @param {NumericArray} V - strided array containing a data point\n* @param {integer} strideV - vector stride\n* @param {NonNegativeInteger} offsetV - vector index offset\n* @returns {NonNegativeInteger} centroid index\n*/\nfunction closestCentroid( dist, k, ndims, C, strideC, offsetC, V, strideV, offsetV ) { // eslint-disable-line max-len\n\tvar cd;\n\tvar c;\n\tvar d;\n\tvar i;\n\n\tcd = PINF;\n\tfor ( i = 0; i < k; i++ ) {\n\t\t// Why the magic number `1`? Because we know that the centroids matrix should be row-major single-segment contiguous.\n\t\td = dist( ndims, C, 1, offsetC, V, strideV, offsetV );\n\t\tif ( d < cd ) {\n\t\t\tcd = d;\n\t\t\tc = i;\n\t\t}\n\t\toffsetC += strideC;\n\t}\n\treturn c;\n}\n\n\n// EXPORTS //\n\nexport default closestCentroid;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Updates a centroid.\n*\n* ## Notes\n*\n* -   Uses Welford's algorithm for updating an arithmetic mean.\n*\n* @private\n* @param {PositiveInteger} ndims - number of dimensions\n* @param {PositiveInteger} N - number of data points in a cluster\n* @param {NumericArray} C - strided array containing centroids\n* @param {PositiveInteger} strideC - centroid column stride\n* @param {NonNegativeInteger} offsetC - centroid index offset\n* @param {NumericArray} V - strided array containing a data point\n* @param {integer} strideV - vector stride\n* @param {NonNegativeInteger} offsetV - vector index offset\n* @returns {NumericArray} strided array containing centroids\n*/\nfunction updateCentroid( ndims, N, C, strideC, offsetC, V, strideV, offsetV ) {\n\tvar delta;\n\tvar ci;\n\tvar i;\n\n\tfor ( i = 0; i < ndims; i++ ) {\n\t\tci = C[ offsetC ];\n\t\tdelta = V[ offsetV ] - ci;\n\t\tci += delta / N;\n\t\tC[ offsetC ] = ci;\n\n\t\toffsetC += strideC;\n\t\toffsetV += strideV;\n\t}\n\treturn C;\n}\n\n\n// EXPORTS //\n\nexport default updateCentroid;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport { ndarray as gcopy } from '@stdlib/blas-base-gcopy';\nimport createMatrix from './matrix.js';\nimport norm from './normalize_matrix.js';\nimport standardize from './standardize_matrix.js';\nimport sample from './init_sample.js';\nimport kmeansplusplus from './init_kmeansplusplus.js';\nimport forgy from './init_forgy.js';\nimport clusters from './init_clusters.js';\n\n\n// MAIN //\n\n/**\n* Returns an initialization accumulator for computing initial centroids.\n*\n* @private\n* @param {ndarray} centroids - matrix for storing centroids\n* @param {ndarray} stats - matrix for storing cluster statistics\n* @param {Function} clusterstats - cluster statistics accumulator\n* @param {(Function|void)} incrstats - mean vector accumulator\n* @param {Function} dist - distance function\n* @param {Options} opts - accumulator options\n* @param {string} opts.metric - distance metric\n* @param {Array} opts.init - initialization metric and associated parameters\n* @param {boolean} opts.normalize - boolean indicating whether to normalize incoming data (only relevant for non-Euclidean distance metrics)\n* @param {*} opts.seed - PRNG seed\n* @returns {Function} accumulator\n*/\nfunction init( centroids, stats, clusterstats, incrstats, dist, opts ) {\n\tvar buffer;\n\tvar ndims;\n\n\tndims = centroids.shape[ 1 ];\n\treturn accumulator;\n\n\t/**\n\t* Computes initial centroids and associated cluster statistics.\n\t*\n\t* @private\n\t* @param {ndarray} v - data vector\n\t* @returns {boolean} boolean indicating whether an accumulator has finished computing initial centroids\n\t*/\n\tfunction accumulator( v ) {\n\t\t// If this is the first data vector, we need to begin caching data vectors for future centroid initialization...\n\t\tif ( buffer === void 0 ) {\n\t\t\tbuffer = createMatrix( opts.init[1], ndims, true ); // low-level\n\t\t\tbuffer.count = 0;\n\t\t}\n\t\t// Check if we are still building our cache of data vectors...\n\t\tif ( buffer.count < opts.init[ 1 ] ) {\n\t\t\t// Copy data into the buffer (why? because (1) we have no guarantee that program execution is synchronous, and, thus, we have no guarantee that data vectors will not have been mutated before sampling, and (2) we can freely mutate buffer data, as may be needed during normalization):\n\t\t\tgcopy( ndims, v.data, v.strides[0], v.offset, buffer.data, buffer.strides[1], buffer.strides[0]*buffer.count ); // eslint-disable-line max-len\n\n\t\t\t// Increment the data vector counter:\n\t\t\tbuffer.count += 1;\n\n\t\t\t// Only proceed to perform centroid initialization if the cache is still not full...\n\t\t\tif ( buffer.count < opts.init[ 1 ] ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t// If required by the metric, normalize the data vectors along the dimensions...\n\t\tif ( opts.normalize ) {\n\t\t\tif ( opts.metric === 'cosine' ) {\n\t\t\t\tbuffer = norm( buffer );\n\t\t\t} else if ( opts.metric === 'correlation' ) {\n\t\t\t\tbuffer = standardize( buffer, incrstats() );\n\t\t\t}\n\t\t}\n\t\t// Compute initial centroids...\n\t\tif ( opts.init[ 0 ] === 'forgy' ) {\n\t\t\tcentroids = forgy( centroids, buffer, opts.seed );\n\t\t} else if ( opts.init[ 0 ] === 'sample' ) {\n\t\t\tcentroids = sample( centroids, buffer, opts.seed );\n\t\t} else {\n\t\t\tcentroids = kmeansplusplus( centroids, buffer, opts.metric, opts.init[2], opts.seed ); // eslint-disable-line max-len\n\t\t}\n\t\t// Compute initial clusters:\n\t\tclusters( buffer, centroids, stats, clusterstats, dist );\n\n\t\treturn true;\n\t}\n}\n\n\n// EXPORTS //\n\nexport default init;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport { factory as factory } from '@stdlib/random-base-discrete-uniform';\nimport incrmean from '@stdlib/stats-incr-mean';\n\n\n// MAIN //\n\n/**\n* Initializes centroids by randomly assigning each data point to cluster and computing centroids.\n*\n* ## References\n*\n* -   Forgy, E. 1965. \"Cluster Analysis of Multivariate Data: Efficiency versus Interpretability of Classification.\" _Biometrics_ 21 (3): 768–69.\n*\n* @private\n* @param {ndarray} out - output centroids `kxd` matrix\n* @param {ndarray} buffer - buffer containing data points\n* @param {*} seed - PRNG seed\n* @returns {ndarray} centroids\n*/\nfunction forgy( out, buffer, seed ) {\n\tvar randi;\n\tvar obuf;\n\tvar npts;\n\tvar buf;\n\tvar sb1;\n\tvar sb2;\n\tvar so1;\n\tvar so2;\n\tvar acc;\n\tvar oo;\n\tvar oa;\n\tvar ob;\n\tvar c;\n\tvar M;\n\tvar N;\n\tvar i;\n\tvar j;\n\n\tM = out.shape[ 0 ];\n\tN = out.shape[ 1 ];\n\n\tobuf = out.data;\n\tso1 = out.strides[ 0 ];\n\tso2 = out.strides[ 1 ];\n\too = out.offset;\n\n\tbuf = buffer.data;\n\tnpts = buffer.shape[ 0 ];\n\tsb1 = buffer.strides[ 0 ];\n\tsb2 = buffer.strides[ 1 ];\n\tob = buffer.offset;\n\n\t// Initialize a PRNG for randomly assigning data points to clusters:\n\trandi = factory( 0, M-1, {\n\t\t'seed': seed\n\t});\n\n\t// Initialize a strided (MxN) array for storing accumulated centroids...\n\tacc = [];\n\tfor ( i = 0; i < M*N; i++ ) {\n\t\tacc.push( incrmean() );\n\t}\n\n\t// Randomly assign each data point to a cluster and update the respective cluster's centroid...\n\tfor ( i = 0; i < npts; i++ ) {\n\t\t// Generate a random cluster index:\n\t\tc = randi();\n\n\t\t// Compute the accumulator index offset:\n\t\toa = N * c;\n\n\t\t// Update the respective cluster centroid:\n\t\tfor ( j = 0; j < N; j++ ) {\n\t\t\tacc[ oa+j ]( buf[ ob+(sb2*j) ] );\n\t\t}\n\t\t// Update the data point index offset:\n\t\tob += sb1;\n\t}\n\t// Update the output matrix...\n\toa = 0;\n\tfor ( i = 0; i < M; i++ ) {\n\t\tfor ( j = 0; j < N; j++ ) {\n\t\t\tobuf[ oo+(so2*j) ] = acc[ oa ]();\n\t\t\toa += 1; // We can simply increment the array pointer as we know that the accumulator array is row-major single-segment contiguous\n\t\t}\n\t\too += so1;\n\t}\n\treturn out;\n}\n\n\n// EXPORTS //\n\nexport default forgy;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport { factory as factory } from '@stdlib/random-sample';\nimport { ndarray as dcopy } from '@stdlib/blas-base-dcopy';\n\n\n// MAIN //\n\n/**\n* Initializes centroids by randomly sampling from a data buffer.\n*\n* @private\n* @param {ndarray} out - output centroids `kxd` matrix\n* @param {ndarray} buffer - buffer from which to sample\n* @param {*} seed - PRNG seed\n* @returns {ndarray} centroids\n*/\nfunction sample( out, buffer, seed ) {\n\tvar rand;\n\tvar inds;\n\tvar obuf;\n\tvar buf;\n\tvar sb1;\n\tvar sb2;\n\tvar so2;\n\tvar oo;\n\tvar s;\n\tvar M;\n\tvar N;\n\tvar i;\n\n\tM = out.shape[ 0 ];\n\tN = out.shape[ 1 ];\n\n\tobuf = out.data;\n\tso2 = out.strides[ 1 ];\n\too = out.offset;\n\n\tbuf = buffer.data;\n\tsb1 = buffer.strides[ 0 ];\n\tsb2 = buffer.strides[ 1 ];\n\n\t// Generate an array of data vector indices...\n\tinds = [];\n\tfor ( i = 0; i < buffer.shape[ 0 ]; i++ ) {\n\t\tinds.push( i );\n\t}\n\t// Only randomly sample from the data buffer if the number of centroids is not equal to the number of data vectors...\n\tif ( M === inds.length ) {\n\t\t// Buffer already qualifies as a \"random\" sample:\n\t\ts = inds;\n\t} else {\n\t\t// Create a seeded random sampler (without replacement):\n\t\trand = factory({\n\t\t\t'seed': seed,\n\t\t\t'size': M,\n\t\t\t'mutate': false,\n\t\t\t'replacement': false\n\t\t});\n\n\t\t// Generate a random sample:\n\t\ts = rand( inds );\n\t}\n\t// Update the centroids...\n\tfor ( i = 0; i < M; i++ ) {\n\t\t// Note: the following is likely to be an \"out-of-order\" copy...\n\t\tdcopy( N, buf, sb2, sb1*s[i], obuf, so2, oo );\n\t}\n\treturn out;\n}\n\n\n// EXPORTS //\n\nexport default sample;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport closestCentroid from './find_closest_centroid.js';\nimport updateCentroid from './update_centroid.js';\n\n\n// MAIN //\n\n/**\n* Initializes clusters and associated statistics given a set of centroids.\n*\n* ## Notes\n*\n* -   We follow the same approach when calculating cluster statistics as if the centroids had been provided by a user (i.e., not computed internally), as this ensures consistency with how statistics are computed when subsequent data vectors are provided to the accumulator.\n*\n* @private\n* @param {ndarray} data - matrix containing data points\n* @param {ndarray} centroids - matrix containing centroids\n* @param {ndarray} stats - matrix containing cluster statistics\n* @param {Function} acc - cluster statistics accumulator\n* @param {Function} dist - distance function\n*/\nfunction clusters( data, centroids, stats, acc, dist ) {\n\tvar ndims;\n\tvar cbuf;\n\tvar dbuf;\n\tvar npts;\n\tvar sc;\n\tvar sd;\n\tvar oc;\n\tvar od;\n\tvar N;\n\tvar k;\n\tvar c;\n\tvar d;\n\tvar i;\n\n\tk = centroids.shape[ 0 ];\n\tndims = centroids.shape[ 1 ];\n\tnpts = data.shape[ 0 ];\n\n\tcbuf = centroids.data;\n\tsc = centroids.strides[ 0 ];\n\n\tdbuf = data.data;\n\tsd = data.strides[ 0 ];\n\tod = 0;\n\n\tfor ( i = 0; i < npts; i++ ) {\n\t\t// Find the closest centroid by computing the distance from the provided data point to each centroid:\n\t\tc = closestCentroid( dist, k, ndims, cbuf, sc, 0, dbuf, 1, od ); // Magic numbers arise from knowing that matrices are row-major single-segment contiguous\n\n\t\t// Compute the centroids buffer index offset to point to the closest centroid:\n\t\toc = sc * c;\n\n\t\t// Update the closest centroid:\n\t\tN = stats.get( c, 0 ) + 1;\n\t\tupdateCentroid( ndims, N, cbuf, 1, oc, dbuf, 1, od ); // Magic number `1` as we know that these matrices are row-major single-segment contiguous\n\n\t\t// Recompute the distance based on the updated centroid position:\n\t\td = dist( ndims, cbuf, 1, oc, dbuf, 1, od ); // Magic number `1` as we know that these matrices are row-major single-segment contiguous\n\n\t\t// Update cluster statistics:\n\t\tacc( c, d );\n\n\t\t// Increment the data buffer index offset to point to the next data point:\n\t\tod += sd;\n\t}\n}\n\n\n// EXPORTS //\n\nexport default clusters;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport sqrt from '@stdlib/math-base-special-sqrt';\n\n\n// MAIN //\n\n/**\n* Returns an accumulator for computing cluster statistics.\n*\n* @private\n* @param {ndarray} out - matrix for storing cluster statistics\n* @param {PositiveInteger} k - number of clusters\n* @returns {Function} accumulator\n*/\nfunction stats( out, k ) {\n\tvar M2;\n\tvar i;\n\n\t// Create an array for storing second moments:\n\tM2 = [];\n\tfor ( i = 0; i < k; i++ ) {\n\t\tM2.push( 0.0 );\n\t}\n\n\treturn accumulator;\n\n\t/**\n\t* Updates cluster statistics.\n\t*\n\t* @private\n\t* @param {NonNegativeInteger} c - cluster index to which a data point belongs\n\t* @param {number} dist - a data point's squared distance to its respective centroid\n\t* @returns {ndarray} matrix containing cluster statistics\n\t*/\n\tfunction accumulator( c, dist ) {\n\t\tvar delta;\n\t\tvar mu;\n\t\tvar N;\n\n\t\t// Update number of data points belonging to a cluster:\n\t\tN = out.get( c, 0 ) + 1;\n\t\tout.set( c, 0, N );\n\n\t\t// Update the total sum of squared distances within a cluster:\n\t\tout.set( c, 1, out.get( c, 1 )+dist );\n\n\t\t// Update the cluster's squared distance mean and standard deviation (using Welford's algorithm):\n\t\tmu = out.get( c, 2 );\n\t\tdelta = dist - mu;\n\t\tmu += delta / N;\n\t\tM2[ c ] += delta * ( dist-mu );\n\t\tout.set( c, 2, mu );\n\t\tout.set( c, 3, sqrt( M2[c]/(N-1) ) );\n\n\t\treturn out;\n\t}\n}\n\n\n// EXPORTS //\n\nexport default stats;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport incrmeanstdev from '@stdlib/stats-incr-meanstdev';\nimport Float64Array from '@stdlib/array-float64';\n\n\n// MAIN //\n\n/**\n* Initializes incremental accumulators for computing the mean vector and associated standard deviation along each dimension.\n*\n* @private\n* @param {PositiveInteger} ndims - number of dimensions\n* @returns {Object} accumulators\n*/\nfunction incrstats( ndims ) {\n\tvar stride;\n\tvar nstats;\n\tvar acc;\n\tvar out;\n\tvar ob;\n\tvar i;\n\n\t// Define the number of computed statistics:\n\tnstats = 2;\n\n\t// Create a single linear array in which to store accumulated statistics:\n\tout = new Float64Array( ndims*nstats );\n\n\t// Define the array buffer stride (in bytes):\n\tstride = nstats * out.BYTES_PER_ELEMENT;\n\n\t// Initialize accumulators which will write to sections of the linear array:\n\tacc = [];\n\tob = 0;\n\tfor ( i = 0; i < ndims; i++ ) {\n\t\tacc.push( incrmeanstdev( new Float64Array( out.buffer, ob, nstats ) ) );\n\t\tob += stride; // buffer offset\n\t}\n\treturn accumulator;\n\n\t/**\n\t* If provided a data point vector, updates the mean vector and associated standard deviation along each dimension. If not provided a data point vector, returns the current mean vector and associated standard deviation along each dimension.\n\t*\n\t* @private\n\t* @param {ndarray} [vec] - data point vector\n\t* @returns {Float64Array} current mean vector and associated standard deviation along each dimension\n\t*/\n\tfunction accumulator( vec ) {\n\t\tvar i;\n\t\tif ( arguments.length === 0 ) {\n\t\t\treturn out;\n\t\t}\n\t\tfor ( i = 0; i < ndims; i++ ) {\n\t\t\tacc[ i ]( vec.get( i ) );\n\t\t}\n\t\treturn out;\n\t}\n}\n\n\n// EXPORTS //\n\nexport default incrstats;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport { isPrimitive as isPositiveInteger } from '@stdlib/assert-is-positive-integer';\nimport isMatrixLike from '@stdlib/assert-is-matrix-like';\nimport isVectorLike from '@stdlib/assert-is-vector-like';\nimport setReadOnly from '@stdlib/utils-define-nonenumerable-read-only-property';\nimport format from '@stdlib/string-format';\nimport minstd from '@stdlib/random-base-minstd-shuffle';\nimport floor from '@stdlib/math-base-special-floor';\nimport ln from '@stdlib/math-base-special-ln';\nimport dcopy from '@stdlib/blas-base-dcopy';\nimport createMatrix from './matrix.js';\nimport copyMatrix from './copy_matrix.js';\nimport createVector from './vector.js';\nimport copyVector from './copy_vector.js';\nimport validate from './validate.js';\nimport INIT_DEFAULTS from './init_defaults.json';\nimport initialization from './init.js';\nimport statistics from './stats.js';\nimport incrstatistics from './incrstats.js';\nimport squaredEuclidean from './squared_euclidean.js';\nimport squaredCosine from './squared_cosine.js';\nimport squaredCorrelation from './squared_correlation.js';\nimport closestCentroid from './find_closest_centroid.js';\nimport updateCentroid from './update_centroid.js';\nimport normalize from './normalize.js';\nimport normalizeMatrix from './normalize_matrix.js';\nimport standardize from './standardize.js';\nimport standardizeMatrix from './standardize_matrix.js';\n\n\n// VARIABLES //\n\n// Number of cluster statistics:\nvar NSTATS = 4; // [ n_obs, sum_squared_dist, mean_squared_dist, stdev_squared_dist ]\n\n\n// FUNCTIONS //\n\n/**\n* Returns a results object.\n*\n* @private\n* @param {PositiveInteger} k - number of clusters\n* @param {PositiveInteger} ndims - number of dimensions\n* @returns {Object} results object\n*/\nfunction createResults( k, ndims ) {\n\tvar out = {};\n\tout.centroids = createMatrix( k, ndims, false ); // high-level\n\tout.stats = createMatrix( k, NSTATS, false ); // high-level\n\treturn out;\n}\n\n\n// MAIN //\n\n/**\n* Returns an accumulator function which incrementally partitions data into `k` clusters.\n*\n* @param {(PositiveInteger|ndarray)} k - number of clusters or a `k x ndims` matrix containing initial centroids\n* @param {PositiveInteger} [ndims] - number of dimensions (should only be provided if provided a numeric `k` argument)\n* @param {Options} [options] - function options\n* @param {string} [options.metric=\"euclidean\"] - distance metric\n* @param {ArrayLikeObject} [options.init] - method for determining initial centroids\n* @param {boolean} [options.normalize=true] - boolean indicating whether to normalize incoming data (only relevant for non-Euclidean distance metrics)\n* @param {boolean} [options.copy=true] - boolean indicating whether to copy incoming data to prevent mutation during normalization\n* @param {*} [options.seed] - PRNG seed\n* @throws {TypeError} first argument must be a positive integer\n* @throws {TypeError} second argument must be a positive integer\n* @throws {TypeError} options argument must be an object\n* @throws {TypeError} must provide valid options\n* @throws {RangeError} when using sampling to generate initial centroids, the sample size must be greater than or equal to the number of clusters\n* @returns {Function} accumulator function\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray from '@stdlib/ndarray-ctor';\n*\n* // Define initial centroid locations:\n* var buffer = [\n*     0.0, 0.0,\n*     1.0, 1.0,\n*     1.0, -1.0,\n*     -1.0, -1.0,\n*     -1.0, 1.0\n* ];\n* var shape = [ 5, 2 ];\n* var strides = [ 2, 1 ];\n* var offset = 0;\n* var order = 'row-major';\n*\n* var centroids = ndarray( 'float64', buffer, shape, strides, offset, order );\n*\n* // Create a k-means accumulator:\n* var accumulator = incrkmeans( centroids );\n*\n* var out = accumulator();\n* // returns {...}\n*\n* // Create a data vector:\n* buffer = new Float64Array( 2 );\n* shape = [ 2 ];\n* strides = [ 1 ];\n*\n* var vec = ndarray( 'float64', buffer, shape, strides, offset, order );\n*\n* // Provide data to the accumulator:\n* vec.set( 0, 2.0 );\n* vec.set( 1, 1.0 );\n*\n* out = accumulator( vec );\n* // returns {...}\n*\n* vec.set( 0, -5.0 );\n* vec.set( 1, 3.14 );\n*\n* out = accumulator( vec );\n* // returns {...}\n*\n* // Retrieve the current cluster results:\n* out = accumulator();\n* // returns {...}\n*/\nfunction incrkmeans() {\n\tvar clusterstats;\n\tvar centroids;\n\tvar incrstats;\n\tvar options;\n\tvar results;\n\tvar vcopy;\n\tvar stats;\n\tvar ndims;\n\tvar dist;\n\tvar opts;\n\tvar init;\n\tvar err;\n\tvar FLG;\n\tvar k;\n\n\tif ( isMatrixLike( arguments[ 0 ] ) ) {\n\t\tk = arguments[ 0 ].shape[ 0 ];\n\t\tndims = arguments[ 0 ].shape[ 1 ];\n\t\tcentroids = createMatrix( k, ndims, true ); // low-level\n\t\tcentroids = copyMatrix( centroids, arguments[ 0 ] );\n\t\tif ( arguments.length > 1 ) {\n\t\t\toptions = arguments[ 1 ];\n\t\t\tFLG = true;\n\t\t}\n\t} else if ( isPositiveInteger( arguments[ 0 ] ) ) {\n\t\tk = arguments[ 0 ];\n\t\tndims = arguments[ 1 ];\n\t\tif ( !isPositiveInteger( ndims ) ) {\n\t\t\tthrow new TypeError( format( 'invalid argument. Argument specifying number of dimensions must be a positive integer. Value: `%s`.', ndims ) );\n\t\t}\n\t\tif ( arguments.length > 2 ) {\n\t\t\toptions = arguments[ 2 ];\n\t\t\tFLG = true;\n\t\t}\n\t} else {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must either be a positive integer specifying the number of clusters or a matrix containing initial centroids. Value: `%s`.', arguments[ 0 ] ) );\n\t}\n\topts = {\n\t\t'metric': 'euclidean',\n\t\t'init': INIT_DEFAULTS[ 'kmeans++' ].slice(),\n\t\t'seed': minstd(),\n\t\t'normalize': true,\n\t\t'copy': true\n\t};\n\topts.init[ 1 ] = k; // Note: this default applies to all initialization methods\n\topts.init[ 2 ] = 2 + floor( ln( k ) ); // Note: from Arthur's and Vassilvitskii's paper \"kmeans++: The Advantages of Careful Seeding\" (see conclusion)\n\tif ( FLG ) {\n\t\terr = validate( opts, options );\n\t\tif ( err ) {\n\t\t\tthrow err;\n\t\t}\n\t}\n\tif ( opts.init[ 1 ] < k ) {\n\t\tthrow new RangeError( format( 'invalid option. First `%s` parameter option must be greater than or equal to the number of clusters. Options: `%f`.', 'init', opts.init[ 1 ] ) );\n\t}\n\t// Initialize a results object:\n\tresults = createResults( k, ndims );\n\n\t// Initialize an internal matrix for tabulating cluster statistics:\n\tstats = createMatrix( k, NSTATS, true ); // low-level\n\n\t// Initialize an internal cluster statistics accumulator:\n\tclusterstats = statistics( stats, k );\n\n\t// Initialize metric-related variables...\n\tif ( opts.metric === 'cosine' ) {\n\t\tdist = squaredCosine;\n\n\t\t// Initialize a scratch vector for copying input vectors:\n\t\tif ( opts.copy ) {\n\t\t\tvcopy = createVector( ndims, true ); // low-level\n\t\t}\n\t} else if ( opts.metric === 'correlation' ) {\n\t\tdist = squaredCorrelation;\n\n\t\t// Initialize an accumulator for computing the mean vector and associated standard deviation along each dimension:\n\t\tif ( opts.normalize ) {\n\t\t\tincrstats = incrstatistics( ndims );\n\t\t}\n\t\t// Initialize a scratch vector for copying input vectors:\n\t\tif ( opts.copy ) {\n\t\t\tvcopy = createVector( ndims, true ); // low-level\n\t\t}\n\t} else {\n\t\tdist = squaredEuclidean;\n\t}\n\t// Check if we need to compute initial centroids...\n\tif ( centroids === void 0 ) {\n\t\t// Initialize an internal matrix for storing centroids:\n\t\tcentroids = createMatrix( k, ndims, true ); // low-level\n\n\t\t// Initialize an accumulator for computing initial centroids:\n\t\tinit = initialization( centroids, stats, clusterstats, incrstats, dist, opts ); // eslint-disable-line max-len\n\t} else {\n\t\t// Update cluster results to include the initial centroids (why? so that, even if no data is provided, the `results` object contains the provided centroids):\n\t\tcopyMatrix( results.centroids, centroids );\n\t}\n\t// Attach properties and methods to the accumulator:\n\tsetReadOnly( accumulator, 'seed', opts.seed );\n\tsetReadOnly( accumulator, 'predict', predict );\n\n\treturn accumulator;\n\n\t/**\n\t* If provided a data point vector, the accumulator function returns updated cluster results. If not provided a data point vector, the accumulator function returns the current cluster results.\n\t*\n\t* @private\n\t* @param {ndarray} [vec] - data vector\n\t* @throws {TypeError} must provide a 1-dimensional ndarray\n\t* @throws {Error} vector length must match centroid dimensions\n\t* @returns {(Object|null)} cluster results or null\n\t*/\n\tfunction accumulator( vec ) {\n\t\tvar bool;\n\t\tvar cbuf;\n\t\tvar vbuf;\n\t\tvar sbuf;\n\t\tvar sv;\n\t\tvar sc;\n\t\tvar ov;\n\t\tvar oc;\n\t\tvar v;\n\t\tvar N;\n\t\tvar d;\n\t\tvar c;\n\t\tif ( arguments.length === 0 ) {\n\t\t\tif ( init ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn results;\n\t\t}\n\t\tv = vec; // Why? We mention `arguments` in the function and perform a subsequent reassignment.\n\t\tif ( !isVectorLike( v ) ) {\n\t\t\tthrow new TypeError( format( 'invalid argument. Must provide a one-dimensional ndarray. Value: `%s`.', v ) );\n\t\t}\n\t\tif ( v.shape[ 0 ] !== ndims ) {\n\t\t\tthrow new Error( format( 'invalid argument. Vector length must match centroid dimensions. Expected: `%u``. Actual: `%u``.', ndims, v.shape[ 0 ] ) );\n\t\t}\n\t\t// Check if we need to update the data point mean vector...\n\t\tif ( incrstats ) {\n\t\t\tincrstats( v );\n\t\t}\n\t\t// Check if we have yet to compute initial centroids...\n\t\tif ( init ) {\n\t\t\tbool = init( v );\n\t\t\tif ( bool === false ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t// De-reference `init` so that it and its internal variables can be garbage collected:\n\t\t\tinit = void 0;\n\t\t} else {\n\t\t\t// If required by the metric, normalize the data vector...\n\t\t\tif ( opts.normalize ) {\n\t\t\t\tif ( opts.metric === 'cosine' ) {\n\t\t\t\t\tif ( opts.copy ) {\n\t\t\t\t\t\tv = copyVector( vcopy, v );\n\t\t\t\t\t}\n\t\t\t\t\tnormalize( ndims, v.data, v.strides[ 0 ], v.offset );\n\t\t\t\t} else if ( opts.metric === 'correlation' ) {\n\t\t\t\t\tif ( opts.copy ) {\n\t\t\t\t\t\tv = copyVector( vcopy, v );\n\t\t\t\t\t}\n\t\t\t\t\tsbuf = incrstats();\n\n\t\t\t\t\t// Magic numbers come from knowing that `sbuf` is an interleaved strided array...\n\t\t\t\t\tstandardize( ndims, v.data, v.strides[ 0 ], v.offset, sbuf, 2, 0, sbuf, 2, 1 ); // eslint-disable-line max-len\n\t\t\t\t}\n\t\t\t}\n\t\t\tcbuf = centroids.data;\n\t\t\tsc = centroids.strides[ 0 ];\n\n\t\t\tvbuf = v.data;\n\t\t\tsv = v.strides[ 0 ];\n\t\t\tov = v.offset;\n\n\t\t\t// Find the closest centroid by computing the distance from the provided data point to each centroid:\n\t\t\tc = closestCentroid( dist, k, ndims, cbuf, sc, 0, vbuf, sv, ov ); // Magic number `0` for offset as we know that the matrix view begins at the first buffer element\n\n\t\t\t// Compute the centroids buffer index offset to point to the closest centroid:\n\t\t\toc = sc * c;\n\n\t\t\t// Update the closest centroid:\n\t\t\tN = stats.get( c, 0 ) + 1;\n\t\t\tupdateCentroid( ndims, N, cbuf, 1, oc, vbuf, sv, ov ); // Magic number `1` as we know that the matrix is row-major single-segment contiguous\n\n\t\t\t// Recompute the distance based on the updated centroid position:\n\t\t\td = dist( ndims, cbuf, 1, oc, vbuf, sv, ov ); // Magic number `1` as we know that the matrix is row-major single-segment contiguous\n\n\t\t\t// Update cluster statistics:\n\t\t\tclusterstats( c, d );\n\t\t}\n\t\t// Update the results object:\n\t\tdcopy( centroids.length, centroids.data, 1, results.centroids.data, 1 ); // Magic number `1` as we know that these matrices are row-major single-segment contiguous\n\t\tdcopy( stats.length, stats.data, 1, results.stats.data, 1 ); // Magic number `1` as we know that these matrices are row-major single-segment contiguous\n\n\t\treturn results;\n\t}\n\n\t/**\n\t* Computes data point distances to centroids and returns centroid assignment predictions.\n\t*\n\t* @private\n\t* @param {ndarray} [out] - output vector for storing centroid assignment predictions\n\t* @param {ndarray} X - matrix containing data points (`n x d`, where `n` is the number of data points and `d` is the number of dimensions)\n\t* @throws {TypeError} output argument must be a vector\n\t* @throws {TypeError} must provide a matrix\n\t* @throws {Error} vector length must match number of data points\n\t* @throws {Error} number of matrix columns must match centroid dimensions\n\t* @returns {(ndarray|null)} vector containing centroid (index) predictions or null\n\t*/\n\tfunction predict( out, X ) {\n\t\tvar xbuf;\n\t\tvar cbuf;\n\t\tvar npts;\n\t\tvar sx1;\n\t\tvar sx2;\n\t\tvar sc;\n\t\tvar ox;\n\t\tvar x;\n\t\tvar o;\n\t\tvar c;\n\t\tvar i;\n\t\tif ( arguments.length > 1 ) {\n\t\t\tif ( !isVectorLike( out ) ) {\n\t\t\t\tthrow new TypeError( format( 'invalid argument. Output argument must be a one-dimensional ndarray. Value: `%s`.', out ) );\n\t\t\t}\n\t\t\to = out;\n\t\t\tx = X;\n\t\t} else {\n\t\t\tx = out;\n\t\t}\n\t\tif ( !isMatrixLike( x ) ) {\n\t\t\tthrow new TypeError( format( 'invalid argument. Must provide a two-dimensional ndarray. Value: `%s`.', x ) );\n\t\t}\n\t\tif ( x.shape[ 1 ] !== ndims ) {\n\t\t\tthrow new Error( format( 'invalid argument. Number of matrix columns must match centroid dimensions. Expected: `%u`. Actual: `%u`.', ndims, x.shape[ 1 ] ) );\n\t\t}\n\t\tif ( o === void 0 ) {\n\t\t\to = createVector( x.shape[ 0 ], false ); // high-level\n\t\t} else if ( o.length !== x.shape[ 0 ] ) {\n\t\t\tthrow new Error( format( 'invalid argument. Output vector length must match the number of data points. Expected: `%u`. Actual: `%u`.', x.shape[ 0 ], o.length ) );\n\t\t}\n\t\tif ( init ) {\n\t\t\treturn null;\n\t\t}\n\t\tnpts = x.shape[ 0 ];\n\n\t\t// If required by the metric, normalize the data vectors along the dimensions...\n\t\tif ( opts.normalize ) {\n\t\t\tif ( opts.metric === 'cosine' ) {\n\t\t\t\tif ( opts.copy ) {\n\t\t\t\t\tx = copyMatrix( createMatrix( npts, ndims, true ), x ); // low-level\n\t\t\t\t}\n\t\t\t\tx = normalizeMatrix( x );\n\t\t\t} else if ( opts.metric === 'correlation' ) {\n\t\t\t\tif ( opts.copy ) {\n\t\t\t\t\tx = copyMatrix( createMatrix( npts, ndims, true ), x ); // low-level\n\t\t\t\t}\n\t\t\t\tx = standardizeMatrix( x, incrstats() );\n\t\t\t}\n\t\t}\n\t\tcbuf = centroids.data;\n\t\tsc = centroids.strides[ 0 ];\n\n\t\txbuf = x.data;\n\t\tsx1 = x.strides[ 0 ];\n\t\tsx2 = x.strides[ 1 ];\n\t\tox = x.offset;\n\n\t\t// For each data point, find the closest centroid...\n\t\tfor ( i = 0; i < npts; i++ ) {\n\t\t\tc = closestCentroid( dist, k, ndims, cbuf, sc, 0, xbuf, sx2, ox ); // Magic number `0` for offset as we know that the matrix view begins at the first buffer element\n\n\t\t\t// Update the output vector:\n\t\t\to.set( i, c );\n\n\t\t\t// Compute the data point buffer index offset to point to the next data point:\n\t\t\tox += sx1;\n\t\t}\n\t\treturn o;\n\t}\n}\n\n\n// EXPORTS //\n\nexport default incrkmeans;\n"],"names":["createMatrix","m","n","bool","bctor","ctor","Float64Array","copyMatrix","Y","X","xbuf","ybuf","sx1","sx2","sy1","sy2","ox","oy","M","N","i","shape","data","strides","offset","gcopy","createVector","copyVector","out","src","validate","opts","options","isObject","TypeError","format","hasOwnProp","metric","contains","METRICS","join","isArrayLike","init","INIT_METHODS","length","isPositiveInteger","normalize","isBoolean","copy","seed","strideX","offsetX","xi","v","sqrt","mat","mbuf","sm1","sm2","om","norm","standardize","mean","strideM","offsetM","stdev","strideS","offsetS","mi","si","stats","squaredEuclidean","strideY","offsetY","d","yi","s","euclidean","dot","squaredCosine","squaredCorrelation","dapply","dist","npts","ndims","matrix","ci","offsetC","offsetD","strideD","buf","closestCentroid","k","C","strideC","V","strideV","offsetV","cd","c","PINF","updateCentroid","centroids","clusterstats","incrstats","buffer","count","randi","obuf","sb1","sb2","so1","so2","acc","oo","oa","ob","j","factory","push","incrmean","forgy","inds","size","mutate","replacement","rand","dcopy","sample","trials","dhash","probs","csum","bsum","ind","d2","bc","r","t","randu","randint","normalized","Array","kmeansplusplus","cbuf","dbuf","sc","sd","oc","od","get","clusters","M2","delta","mu","set","stride","BYTES_PER_ELEMENT","incrmeanstdev","vec","arguments","createResults","incrkmeans","results","vcopy","err","FLG","isMatrixLike","INIT_DEFAULTS","slice","minstd","floor","ln","RangeError","statistics","incrstatistics","initialization","setReadOnly","accumulator","predict","vbuf","sbuf","sv","ov","isVectorLike","Error","x","o","normalizeMatrix","standardizeMatrix"],"mappings":"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"}